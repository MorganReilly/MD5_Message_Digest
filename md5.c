/* Morgan Reilly -- G00303598

-- MD5 Message Digest Algorithm --

References:
   [1] http://cacr.uwaterloo.ca/hac/about/chap9.pdf -- HandBook of Applied Cryptography, Chapter 9.49
   [2] https://www.iusmentis.com/technology/hashfunctions/md5/ -- MD5 Diagram (Block Processing)
   [3] http://practicalcryptography.com/hashes/md5-hash/ -- MD5 Specification
   [4] https://www.ietf.org/rfc/rfc1321.txt -- MD5 Specification
   [5] https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/ -- Bitwise Operations
   [6] https://code.woboq.org/linux/linux/crypto/md4.c.html -- MD4 code -- used for helping me understand the rounds
   [7] http://www.herongyang.com/Cryptography/MD5-Message-Digest-Algorithm-Overview.html
   [8] https://cs.indstate.edu/~fsagar/doc/paper.pdf

About MD5:
   MD5 was designed as a strengthened version of MD4, prior to actual MD4 collisions being found.
   MD5 is obtained from MD4 by making modifications.
   These changes will be outlined in this project where implemented.
   MD5 operates on 32-bit words.
*/
#include "md5.h"
#include <stdio.h>
#include <inttypes.h>
#include <endian.h>

/* Constants definition for Transformation routine
   R[4]: A.3 md5.c Page9
*/
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

/* Function Declaration
   These define the function type and parameters of the functions used below
   R[4]: A.3 md5.c Page9
*/
static void MD5Transform PROTO_LIST((UINT4[4], unsigned char[64]));
static void Encode PROTO_LIST((unsigned char *, UINT4 *, unsigned int));
static void Decode PROTO_LIST((UINT4 *, unsigned char *, unsigned int));
static void MD5_memcpy PROTO_LIST((POINTER, POINTER, unsigned int));
static void MD5_memset PROTO_LIST((POINTER, int, unsigned int));
static void MD5File PROTO_LIST((char *));
static void MD5Print PROTO_LIST((unsigned char[16]));

/* Padding Declaration
   R[4]: A.3 md5.c Page9
*/
static unsigned char PADDING[64] = {
    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

/* The Table - R[8]: 3.4.2 The Table
   Pregenerated by using sin function: abs(sin(i + 1)) Ã— 2^32

   Note: This is unused in the code and
   is left as a reference to understand where the values came from.
*/
const uint32_t T[] = {0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
                      0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
                      0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
                      0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
                      0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
                      0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
                      0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
                      0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
                      0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
                      0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
                      0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
                      0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
                      0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
                      0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
                      0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
                      0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};

/* -- Auxillary Functions --
   Input 3 32-bit words --> Produce as output one 32-bit word
   F acts as conditional: if X then Y else Z
   G,H,I act in "bitwise parallel" to produce output from bits of X, Y, Z

   Function Declaratin -- R [3]: The Algorithm
   Also adapted from R[4]: A.3 md5.c (Page9, Page10)  
*/
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))
#define LSHIFT(x, n) (((x) << (n)) | ((x) >> (32 - (n))))

/* Defining rounds
   Where:
   a,b,c,d --> Initial buffer values

   Adapted from R[4]: A.3 md5.c (Page9, Page10)  
*/
#define FF(a, b, c, d, x, s, ac)                     \
    {                                                \
        (a) += F((b), (c), (d)) + (x) + (UINT4)(ac); \
        (a) = LSHIFT((a), (s));                      \
        (a) += (b);                                  \
    }
#define GG(a, b, c, d, x, s, ac)                     \
    {                                                \
        (a) += G((b), (c), (d)) + (x) + (UINT4)(ac); \
        (a) = LSHIFT((a), (s));                      \
        (a) += (b);                                  \
    }
#define HH(a, b, c, d, x, s, ac)                     \
    {                                                \
        (a) += H((b), (c), (d)) + (x) + (UINT4)(ac); \
        (a) = LSHIFT((a), (s));                      \
        (a) += (b);                                  \
    }
#define II(a, b, c, d, x, s, ac)                     \
    {                                                \
        (a) += I((b), (c), (d)) + (x) + (UINT4)(ac); \
        (a) = LSHIFT((a), (s));                      \
        (a) += (b);                                  \
    }

/* MD5 Initialisation
   This will begin a new MD5 operation, 
   with a new context to write to.
   R[4]: A.3 md5.c Page10
*/
void MD5Init(context)
    MD5_CTX *context; /* context */
{
    context->count[0] = context->count[1] = 0;
    /* Load magic initialization constants.*/
    context->state[0] = 0x67452301;
    context->state[1] = 0xefcdab89;
    context->state[2] = 0x98badcfe;
    context->state[3] = 0x10325476;
}

/* MD5 block update operation 
   This continues the existing md5 digest,
   processing block after block while updating the context
   R[4]: A.3 md5.c (Page10, Page11)
*/
void MD5Update(context, input, inputLength)
    MD5_CTX *context;     /* context */
unsigned char *input;     /* input block */
unsigned int inputLength; /* length of input block */
{
    unsigned int i, index, partLen;

    /* Compute number of bytes mod 64 */
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);

    /* Update number of bits */
    if ((context->count[0] += ((UINT4)inputLength << 3)) < ((UINT4)inputLength << 3))
        context->count[1]++;
    context->count[1] += ((UINT4)inputLength >> 29);

    partLen = 64 - index;

    // Transform as many times as possible
    if (inputLength >= partLen)
    {
        MD5_memcpy((POINTER)&context->buffer[index], (POINTER)input, partLen);
        MD5Transform(context->state, context->buffer);

        for (i = partLen; i + 63 < inputLength; i += 64)
            MD5Transform(context->state, &input[i]);

        index = 0;
    }
    else
        i = 0;

    /* Buffer remaining input */
    MD5_memcpy((POINTER)&context->buffer[index], (POINTER)&input[i],
               inputLength - i);
}

/* MD5 Finalisation
   This ends the MD5 operation, writes the MD, zeros the context
    R[4]: A.3 md5.c (Page11, Page12)
*/
void MD5Final(digest, context) unsigned char digest[16]; /* message digest */
MD5_CTX *context;                                        /* context */
{
    unsigned char bits[8];
    unsigned int index, padLen;

    // Save number of bits
    Encode(bits, context->count, 8);
    // Pad out to 56 mod 64.
    index = (unsigned int)((context->count[0] >> 3) & 0x3f);
    padLen = (index < 56) ? (56 - index) : (120 - index);
    MD5Update(context, PADDING, padLen);

    // Append length (before padding)
    MD5Update(context, bits, 8);

    // Store state in digest
    Encode(digest, context->state, 16);

    // Zeroize sensitive information.
    MD5_memset((POINTER)context, 0, sizeof(*context));
}

/* MD5 Transform Function
   Next Hash
   Taking a state, and calculating next block 
   R[4]: A.3 md5.c (Page12, Page13)
*/
static void MD5Transform(state, block)
    UINT4 state[4];
unsigned char block[64];
{
    UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];

    Decode(x, block, 64);

    /* Round Declaration 
       Adapted from R[4]: A.3 md5.c (Page12, Page13)
    */
    // Round 1 -- FF
    FF(a, b, c, d, x[0], S11, 0xd76aa478);  /* 1 */
    FF(d, a, b, c, x[1], S12, 0xe8c7b756);  /* 2 */
    FF(c, d, a, b, x[2], S13, 0x242070db);  /* 3 */
    FF(b, c, d, a, x[3], S14, 0xc1bdceee);  /* 4 */
    FF(a, b, c, d, x[4], S11, 0xf57c0faf);  /* 5 */
    FF(d, a, b, c, x[5], S12, 0x4787c62a);  /* 6 */
    FF(c, d, a, b, x[6], S13, 0xa8304613);  /* 7 */
    FF(b, c, d, a, x[7], S14, 0xfd469501);  /* 8 */
    FF(a, b, c, d, x[8], S11, 0x698098d8);  /* 9 */
    FF(d, a, b, c, x[9], S12, 0x8b44f7af);  /* 10 */
    FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
    FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
    FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
    FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
    FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
    FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

    // Round 2 -- GG
    GG(a, b, c, d, x[1], S21, 0xf61e2562);  /* 17 */
    GG(d, a, b, c, x[6], S22, 0xc040b340);  /* 18 */
    GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
    GG(b, c, d, a, x[0], S24, 0xe9b6c7aa);  /* 20 */
    GG(a, b, c, d, x[5], S21, 0xd62f105d);  /* 21 */
    GG(d, a, b, c, x[10], S22, 0x2441453);  /* 22 */
    GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
    GG(b, c, d, a, x[4], S24, 0xe7d3fbc8);  /* 24 */
    GG(a, b, c, d, x[9], S21, 0x21e1cde6);  /* 25 */
    GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
    GG(c, d, a, b, x[3], S23, 0xf4d50d87);  /* 27 */
    GG(b, c, d, a, x[8], S24, 0x455a14ed);  /* 28 */
    GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
    GG(d, a, b, c, x[2], S22, 0xfcefa3f8);  /* 30 */
    GG(c, d, a, b, x[7], S23, 0x676f02d9);  /* 31 */
    GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

    // Round 3 -- HH
    HH(a, b, c, d, x[5], S31, 0xfffa3942);  /* 33 */
    HH(d, a, b, c, x[8], S32, 0x8771f681);  /* 34 */
    HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
    HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
    HH(a, b, c, d, x[1], S31, 0xa4beea44);  /* 37 */
    HH(d, a, b, c, x[4], S32, 0x4bdecfa9);  /* 38 */
    HH(c, d, a, b, x[7], S33, 0xf6bb4b60);  /* 39 */
    HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH(d, a, b, c, x[0], S32, 0xeaa127fa);  /* 42 */
    HH(c, d, a, b, x[3], S33, 0xd4ef3085);  /* 43 */
    HH(b, c, d, a, x[6], S34, 0x4881d05);   /* 44 */
    HH(a, b, c, d, x[9], S31, 0xd9d4d039);  /* 45 */
    HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
    HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
    HH(b, c, d, a, x[2], S34, 0xc4ac5665);  /* 48 */

    // Round 4 -- II
    II(a, b, c, d, x[0], S41, 0xf4292244);  /* 49 */
    II(d, a, b, c, x[7], S42, 0x432aff97);  /* 50 */
    II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
    II(b, c, d, a, x[5], S44, 0xfc93a039);  /* 52 */
    II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
    II(d, a, b, c, x[3], S42, 0x8f0ccc92);  /* 54 */
    II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
    II(b, c, d, a, x[1], S44, 0x85845dd1);  /* 56 */
    II(a, b, c, d, x[8], S41, 0x6fa87e4f);  /* 57 */
    II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
    II(c, d, a, b, x[6], S43, 0xa3014314);  /* 59 */
    II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
    II(a, b, c, d, x[4], S41, 0xf7537e82);  /* 61 */
    II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
    II(c, d, a, b, x[2], S43, 0x2ad7d2bb);  /* 63 */
    II(b, c, d, a, x[9], S44, 0xeb86d391);  /* 64 */

    /* Perform additions which incrememnt each of the four registers */
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;

    // Zeroise sensitive information
    MD5_memset((POINTER)x, 0, sizeof(x));
}

/* Encode the input into output (UINT4  --> unsigned char) 
   Done by assuming length is a multiple of 4
   R[4]: A.3 md5.c Page14
*/
static void Encode(output, input, len) unsigned char *output;
UINT4 *input;
unsigned int len;
{
    unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4)
    {
        output[j] = (unsigned char)(input[i] & 0xff);
        output[j + 1] = (unsigned char)((input[i] >> 8) & 0xff);
        output[j + 2] = (unsigned char)((input[i] >> 16) & 0xff);
        output[j + 3] = (unsigned char)((input[i] >> 24) & 0xff);
    }
}

/* Decode input into output (unsigned char --> UINT4)
   Done by assuming length is a multiple of 4
   R[4]: A.3 md5.c Page14
*/
static void Decode(output, input, length)
    UINT4 *output;
unsigned char *input;
unsigned int length;
{
    unsigned int i, j;

    for (i = 0, j = 0; j < length; i++, j += 4)
        output[i] = ((UINT4)input[j]) | (((UINT4)input[j + 1]) << 8) |
                    (((UINT4)input[j + 2]) << 16) | (((UINT4)input[j + 3]) << 24);
}

/* Memory Copy
   Note: Replace "for loop" with standard memcpy if possible.
   R[4]: A.3 md5.c Page14
*/
static void MD5_memcpy(output, input, len)
    POINTER output;
POINTER input;
unsigned int len;
{
    unsigned int i;

    for (i = 0; i < len; i++)
        output[i] = input[i];
}

/* Memory Set
   Note: Replace "for loop" with standard memcpy if possible.
   R[4]: A.3 md5.c Page15
*/
static void MD5_memset(output, value, len)
    POINTER output;
int value;
unsigned int len;
{
    unsigned int i;

    for (i = 0; i < len; i++)
        ((char *)output)[i] = (char)value;
}

/* Display expected value
   Currently displaying the empty string
*/
void display_expected()
{
    printf("d41d8cd98f00b204e9800998ecf8427e"); // ""
    printf("\n");
}

/* Calculate From File
   R[4]: A.4 mddriver.c Page19
*/
static void MD5File(filename) char *filename;
{
    FILE *file;
    MD5_CTX context;
    int len;
    unsigned char buffer[1024], digest[16];

    if ((file = fopen(filename, "rb")) == NULL)
        printf("%s can't be opened\n", filename);

    else
    {
        MD5Init(&context);
        while (len = fread(buffer, 1, 1024, file))
            MD5Update(&context, buffer, len);
        MD5Final(digest, &context);

        fclose(file);

        printf("(%s) = ", filename);
        MD5Print(digest);
        printf("\n");
    }
}

/* Print Generated MD5 digest
   R[4]: A.4 mddriver.c (Page19, Page20)
*/
static void MD5Print(digest) unsigned char digest[16];
{
    unsigned int i;

    for (i = 0; i < 16; i++)
        printf("%02x", digest[i]);
}

/* Main */
int main(int argc, char *argv[])
{
    /* Disply expected value */
    display_expected();

    /* Generate from file */
    MD5File(argv[1]);
    return 0;
}
