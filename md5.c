/* Morgan Reilly -- G00303598

-- MD5 Message Digest Algorithm --

References:
   [1] http://cacr.uwaterloo.ca/hac/about/chap9.pdf -- HandBook of Applied Cryptography, Chapter 9.49
   [2] https://www.iusmentis.com/technology/hashfunctions/md5/ -- MD5 Diagram (Block Processing)
   [3] http://practicalcryptography.com/hashes/md5-hash/ -- MD5 Specification
   [4] https://www.ietf.org/rfc/rfc1321.txt -- MD5 Specification
   [5] https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/ -- Bitwise Operations
   [6] https://code.woboq.org/linux/linux/crypto/md4.c.html -- MD4 code -- used for helping me understand the rounds
   [7] http://www.herongyang.com/Cryptography/MD5-Message-Digest-Algorithm-Overview.html
   [8] https://cs.indstate.edu/~fsagar/doc/paper.pdf

About MD5:
   MD5 was designed as a strengthened version of MD4, prior to actual MD4 collisions being found.
   MD5 is obtained from MD4 by making modifications.
   These changes will be outlined in this project where implemented.
   MD5 operates on 32-bit words.
*/

#include <stdio.h>
#include <inttypes.h>
#include <endian.h>

/* Definition of a four byte word */
typedef unsigned long int UINT4;
/* Defintion of a word
   R[4]: 2. Terminology and Notation
*/
#define WORD uint32_t

/* Constants definition for Transformation routine
   R[4]: A.3 md5.c Page9
*/
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

/* The Table - R[8]: 3.4.2 The Table
   Pregenerated by using sin function: abs(sin(i + 1)) Ã— 2^32

   Note: This is unused in the code and
   is left as a reference to understand where the values came from.
*/
const uint32_t T[] = {0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
                      0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
                      0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
                      0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
                      0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
                      0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
                      0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
                      0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
                      0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
                      0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
                      0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
                      0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
                      0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
                      0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
                      0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
                      0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};

/* -- Auxillary Functions --
   Input 3 32-bit words --> Produce as output one 32-bit word
   F acts as conditional: if X then Y else Z
   G,H,I act in "bitwise parallel" to produce output from bits of X, Y, Z

   Function Declaratin -- R [3]: The Algorithm
   Also adapted from R[4]: A.3 md5.c (Page9, Page10)  
*/
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))
#define LSHIFT(x, n) (((x) << (n)) | ((x) >> (32 - (n))))

/* Defining rounds
   Where:
   a,b,c,d --> Initial buffer values

   Adapted from R[4]: A.3 md5.c (Page9, Page10)  
*/
#define FF(a, b, c, d, x, s, ac)                     \
    {                                                \
        (a) += F((b), (c), (d)) + (x) + (UINT4)(ac); \
        (a) = LSHIFT((a), (s));                      \
        (a) += (b);                                  \
    }
#define GG(a, b, c, d, x, s, ac)                     \
    {                                                \
        (a) += G((b), (c), (d)) + (x) + (UINT4)(ac); \
        (a) = LSHIFT((a), (s));                      \
        (a) += (b);                                  \
    }
#define HH(a, b, c, d, x, s, ac)                     \
    {                                                \
        (a) += H((b), (c), (d)) + (x) + (UINT4)(ac); \
        (a) = LSHIFT((a), (s));                      \
        (a) += (b);                                  \
    }
#define II(a, b, c, d, x, s, ac)                     \
    {                                                \
        (a) += I((b), (c), (d)) + (x) + (UINT4)(ac); \
        (a) = LSHIFT((a), (s));                      \
        (a) += (b);                                  \
    }

/* Preprocessing
   Create union 512int blocks
*/
typedef union {
    uint64_t sixfour[8];   // 64 * 8 = 512 -- 8 64bit intger array
    uint32_t threetwo[16]; // 32 * 16 = 512 -- 16 32bit integer array
    uint8_t eight[64];     // 8 * 64 = 512 -- 64 8bit integer array
} BLOCK;

/* Represent current parse status */
typedef enum
{
    READ, // Not EOF -- Read OG file
    PAD0, // Pad with 0's
    FINISH
} PADFLAG;

/* Next Hash
   Taking a block M, and calculating next block H
*/
int nexthash(WORD *M, WORD *Hash)
{
    uint32_t a, b, c, d, x[16];
    a = Hash[0];
    b = Hash[1];
    c = Hash[2];
    d = Hash[3];

    /* Round Declaration 
       Adapted from R[4]: A.3 md5.c (Page12, Page13)
    */
    // Round 1 -- FF
    FF(a, b, c, d, x[0], S11, 0xd76aa478);  /* 1 */
    FF(d, a, b, c, x[1], S12, 0xe8c7b756);  /* 2 */
    FF(c, d, a, b, x[2], S13, 0x242070db);  /* 3 */
    FF(b, c, d, a, x[3], S14, 0xc1bdceee);  /* 4 */
    FF(a, b, c, d, x[4], S11, 0xf57c0faf);  /* 5 */
    FF(d, a, b, c, x[5], S12, 0x4787c62a);  /* 6 */
    FF(c, d, a, b, x[6], S13, 0xa8304613);  /* 7 */
    FF(b, c, d, a, x[7], S14, 0xfd469501);  /* 8 */
    FF(a, b, c, d, x[8], S11, 0x698098d8);  /* 9 */
    FF(d, a, b, c, x[9], S12, 0x8b44f7af);  /* 10 */
    FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
    FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
    FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
    FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
    FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
    FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

    // Round 2 -- GG
    GG(a, b, c, d, x[1], S21, 0xf61e2562);  /* 17 */
    GG(d, a, b, c, x[6], S22, 0xc040b340);  /* 18 */
    GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
    GG(b, c, d, a, x[0], S24, 0xe9b6c7aa);  /* 20 */
    GG(a, b, c, d, x[5], S21, 0xd62f105d);  /* 21 */
    GG(d, a, b, c, x[10], S22, 0x2441453);  /* 22 */
    GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
    GG(b, c, d, a, x[4], S24, 0xe7d3fbc8);  /* 24 */
    GG(a, b, c, d, x[9], S21, 0x21e1cde6);  /* 25 */
    GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
    GG(c, d, a, b, x[3], S23, 0xf4d50d87);  /* 27 */
    GG(b, c, d, a, x[8], S24, 0x455a14ed);  /* 28 */
    GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
    GG(d, a, b, c, x[2], S22, 0xfcefa3f8);  /* 30 */
    GG(c, d, a, b, x[7], S23, 0x676f02d9);  /* 31 */
    GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

    // Round 3 -- HH
    HH(a, b, c, d, x[5], S31, 0xfffa3942);  /* 33 */
    HH(d, a, b, c, x[8], S32, 0x8771f681);  /* 34 */
    HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
    HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
    HH(a, b, c, d, x[1], S31, 0xa4beea44);  /* 37 */
    HH(d, a, b, c, x[4], S32, 0x4bdecfa9);  /* 38 */
    HH(c, d, a, b, x[7], S33, 0xf6bb4b60);  /* 39 */
    HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH(d, a, b, c, x[0], S32, 0xeaa127fa);  /* 42 */
    HH(c, d, a, b, x[3], S33, 0xd4ef3085);  /* 43 */
    HH(b, c, d, a, x[6], S34, 0x4881d05);   /* 44 */
    HH(a, b, c, d, x[9], S31, 0xd9d4d039);  /* 45 */
    HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
    HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
    HH(b, c, d, a, x[2], S34, 0xc4ac5665);  /* 48 */

    // Round 4 -- II
    II(a, b, c, d, x[0], S41, 0xf4292244);  /* 49 */
    II(d, a, b, c, x[7], S42, 0x432aff97);  /* 50 */
    II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
    II(b, c, d, a, x[5], S44, 0xfc93a039);  /* 52 */
    II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
    II(d, a, b, c, x[3], S42, 0x8f0ccc92);  /* 54 */
    II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
    II(b, c, d, a, x[1], S44, 0x85845dd1);  /* 56 */
    II(a, b, c, d, x[8], S41, 0x6fa87e4f);  /* 57 */
    II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
    II(c, d, a, b, x[6], S43, 0xa3014314);  /* 59 */
    II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
    II(a, b, c, d, x[4], S41, 0xf7537e82);  /* 61 */
    II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
    II(c, d, a, b, x[2], S43, 0x2ad7d2bb);  /* 63 */
    II(b, c, d, a, x[9], S44, 0xeb86d391);  /* 64 */

    /* Perform additions which incrememnt each of the four registers */
    Hash[0] += a;
    Hash[1] += b;
    Hash[2] += c;
    Hash[3] += d;
}

/* Next Block
   Next hashing block to read
   Read from infile, into M, keeping track of number of bits
   it has currently read.

   Adapted from video instructions: https://github.com/ianmcloughlin/sha256/blob/master/sha256.c
*/
int nextblock(BLOCK *M, FILE *infile, uint64_t *nobits, PADFLAG *status)
{
    int i;
    size_t nobytesread;

    switch (*status)
    {
    case FINISH:
        return 0;
    case PAD0:
        // We need an all-padding block without the 1 bit.
        for (int i = 0; i < 56; i++)
            M->eight[i] = 0x00;
        M->sixfour[7] = htobe64(*nobits);
        *status = FINISH;
        break;
    default:
        // Try to read 64 bytes from the file.
        nobytesread = fread(M->eight, 1, 64, infile);
        *nobits += (8ULL * ((uint64_t)nobytesread));

        if (nobytesread < 56)
        {
            // We can put all padding in this block.
            M->eight[nobytesread] = 0x80;
            for (i = nobytesread + 1; i < 56; i++)
                M->eight[i] = 0x00;
            M->sixfour[7] = htobe64(*nobits);
            *status = FINISH;
        }
        else if (nobytesread < 64)
        {
            // Otherwise we have read between 56 (incl) and 64 (excl) bytes.
            M->eight[nobytesread] = 0x80;
            for (int i = nobytesread + 1; i < 64; i++)
                M->eight[i] = 0x00;
            *status = PAD0;
        }
    }

    // Convert to host endianess, word-size-wise.
    for (i = 0; i < 16; i++)
        M->threetwo[i] = be32toh(M->threetwo[i]);

    return 1;
}

/* Display expected value
   Currently displaying the empty string
*/
void display_expected()
{
    printf("d41d8cd98f00b204e9800998ecf8427e"); // ""
    printf("\n");
}

/* Main */
int main(int argc, char *argv[])
{
    /* Disply expected value */
    display_expected();

    /* Expect command line arg */
    if (argc != 2)
    {
        printf("Error: expected single filename as argument\n");
        return 1;
    }

    FILE *infile = fopen(argv[1], "rb");
    // Error handling -- Can't open file
    if (!infile)
    {
        printf("Error: couldn't open file %s. \n", argv[1]);
        return 1;
    }

    // Initialise MD Buffer -- R [8]: 3.4.3 -- Initialise word buffer
    uint32_t H[] = {0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476};

    // nextblock params
    BLOCK M;
    uint64_t nobits = 0;
    PADFLAG status = READ;
    // Read through all of the padded message blocks.
    // When reading into the block -> Do in 8-bits
    while (nextblock(&M, infile, &nobits, &status))
    {
        // Calculate next Hash value of M, hash value of H
        // Passing as address
        // Using values in array --> Do in 32-bits
        nexthash(M.threetwo, H);
    }

    /* Print to console */
    for (int i = 0; i < 4; i++)
        printf("%02" PRIx32 "", H[i]);
    printf("\n");

    fclose(infile);
    return 0;
}
